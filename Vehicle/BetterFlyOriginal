-- Terrain Hover Vehicle (Climb-Only Max Speed Version) - 7/28/25
local Players = game:GetService("Players")
local UserInputService = cloneref(game:GetService("UserInputService"))
local Workspace = cloneref(game:GetService("Workspace"))
local RunService = cloneref(game:GetService("RunService"))
local Camera = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

if not LPH_JIT_MAX then
    LPH_JIT_MAX = function(...) return ... end
end

local cheat = {
    connections = { renderstepped = {} },
    flyModule = {}
}

RunService.RenderStepped:Connect(function(dt)
    for _, func in pairs(cheat.connections.renderstepped) do
        func(dt)
    end
end)

cheat.utility = {}
cheat.utility.new_renderstepped = function(func)
    cheat.connections.renderstepped[func] = func
    return {
        Disconnect = function()
            cheat.connections.renderstepped[func] = nil
        end
    }
end

do
    local isFlying = false
    local flyConn = nil
    local speed = 347
    local car, middle, lastdir = nil, nil, Vector3.new(1, 0, 0)

    local VehicleIdentifiers = {
        {"Seat", "Plastics"},
        {"lights2", "lights3"},
    }

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist

    local function getMiddle()
        local ok, result = pcall(function()
            return Workspace:WaitForChild("Const", 2)
                :WaitForChild("Ignore", 2)
                :WaitForChild("LocalCharacter", 2)
                :WaitForChild("Middle", 2)
        end)
        return ok and result or nil
    end

    local function resetState()
        car = nil
        middle = nil
        lastdir = Vector3.new(1, 0, 0)
    end

    LocalPlayer.CharacterAdded:Connect(function()
        isFlying = false
        if flyConn then flyConn:Disconnect() flyConn = nil end
        resetState()
    end)

    local function findNearestCar()
        car = nil
        local closest = math.huge
        local origin = middle and middle.Position or Camera.CFrame.Position

        for _, model in pairs(Workspace:GetChildren()) do
            if model:IsA("Model") then
                for _, group in ipairs(VehicleIdentifiers) do
                    local allFound = true
                    for _, name in ipairs(group) do
                        if not model:FindFirstChild(name) then
                            allFound = false
                            break
                        end
                    end
                    if allFound then
                        local refPart = model:FindFirstChild(group[1])
                        if refPart and refPart:IsA("BasePart") then
                            local dist = (refPart.Position - origin).Magnitude
                            if dist < closest then
                                closest = dist
                                car = model
                            end
                        end
                        break
                    end
                end
            end
        end
        if car then
            rayParams.FilterDescendantsInstances = {car}
        end
    end

    local function getGroundY(position)
        local origin = position + Vector3.new(0, 20, 0)
        local direction = Vector3.new(0, -100, 0)
        local result = Workspace:Raycast(origin, direction, rayParams)
        return result and result.Position.Y or position.Y
    end

    local function flyStep()
        if not isFlying then return end

        middle = middle or getMiddle()
        if not middle then return end

        if not car or (car:GetPrimaryPartCFrame().Position - middle.Position).Magnitude > 50 then
            findNearestCar()
            return
        end

        local look = Camera.CFrame.LookVector
        look = Vector3.new(look.X, 0, look.Z).Unit
        local dir = Vector3.zero

        if UserInputService:IsKeyDown(Enum.KeyCode.W) then dir += look end
        if UserInputService:IsKeyDown(Enum.KeyCode.S) then dir -= look end
        if UserInputService:IsKeyDown(Enum.KeyCode.D) then dir += Vector3.new(-look.Z, 0, look.X) end
        if UserInputService:IsKeyDown(Enum.KeyCode.A) then dir += Vector3.new(look.Z, 0, -look.X) end

        if dir ~= Vector3.zero then
            lastdir = dir.Unit
        end

        local move = (dir ~= Vector3.zero and dir or lastdir)
        local horizontalVelocity = Vector3.new(move.X * speed, 0, move.Z * speed)

        local carPos = car:GetPrimaryPartCFrame().Position

        -- Forward terrain prediction
        local scanDistance = 30
        local hoverHeight = 6
        local forwardCheck = carPos + move.Unit * scanDistance
        local aheadY = getGroundY(forwardCheck)

        local currentY = carPos.Y
        local targetY = aheadY + hoverHeight

        local yVelocity = 0
        if targetY > currentY then
            yVelocity = (targetY - currentY) * 12
        else
            yVelocity = 0
        end

        local finalVelocity = Vector3.new(horizontalVelocity.X, yVelocity, horizontalVelocity.Z)

        for _, part in pairs(car:GetChildren()) do
            if part:IsA("BasePart") then
                part.Anchored = false
                part.AssemblyLinearVelocity = finalVelocity
            end
        end
    end

    local function toggleFly()
        isFlying = not isFlying
        warn("Vehicle Fly " .. (isFlying and "enabled" or "disabled"))

        if isFlying then
            resetState()
            middle = getMiddle()
            findNearestCar()
            if not flyConn then
                flyConn = cheat.utility.new_renderstepped(LPH_JIT_MAX(flyStep))
            end
        else
            if flyConn then
                flyConn:Disconnect()
                flyConn = nil
            end
            resetState()
        end
    end

    UserInputService.InputBegan:Connect(function(input, gpe)
        if not gpe and input.KeyCode == Enum.KeyCode.Y then
            toggleFly()
        end
    end)

    cheat.flyModule.Toggle = toggleFly
    cheat.flyModule.IsFlying = function() return isFlying end
end
